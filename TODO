basic logic

we want to insert a new section and program header

update  e_entry     in  elf64_header
        to point to decryptor routine
        must jump back to original entry point after decryption


update  e_phnum     in elf64_header
        increment by one

update  e_shnum     in elf64_header
        increment by one


update  e_shoff     in elf64_header
        (if we move the section header)


after inserting a new program header:
update  first (?) program header:
    - the one which has p_offset=0, p_type=1
    - need to change p_filesz and p_memsz
    - seems like original value is 0x40 (sizeof Elf64_Ehdr) +  sizeof Elf64_Phdr * e_phnum
    since we're updating e_phnum, we should update those two values as well



after iterating through all of Elf64_Phdr check if there is enough room (null bytes) to create a new Elf64_Phdr without overwriting anything

while traversing all program headers, calculate the virtual address for new segment:
    for each section take p_vaddr + multiples of alignment , alignment should be larger than p_memsz
        new segment should start after the largest of all p_vaddr + alignment to avoid overlapping

new program header
    p_type = 1
    p_flags = 5
    p_offset = offset in file
    p_vaddr = p_paddr = calculated previously ^^
    p_memsz = p_filesz = number of bytes written
    p_align = 0x1000


new section header
    sh_name = 0
    sh_type = 1
    sh_flags = 6
    sh_addr = calculated previously ^ ^
    sh_offset = p_offset = offset in file
    sh_size = p_memsz = p_filesz = number of bytes written
    sh_link = 0
    sh_info = 0
    sh_addralign = 1
    sh_entsize = 0


objcopy seems to insert a new section at the end of the file, but before section .shstrtab followed by section header



what to do when we can't insert a new program header?

reasoning:
adding a new program header would be easy if there is enough room (null bytes) next to last program header
however when there is not enough room we would have to "insert" it there, shifting the rest of the data downwards,
that adds the complexity of reculculating and modifying lots of addresses which could potentially break things



APPROACH # 2

find program header which has executable bit set AND/OR
- find program header which contains e_entry,
get p_filesz (should be same as p_memsz) and p_align
to go p_offset + p_filesz, scan till p_align multiple and see if we can inject code there

basically find a null byte "hole" at the end of the executable segment and fill that space

this is much simpler and we probably won't break as much stuff when we do it,
the only thing we would want to change in the elf header is the entry address


